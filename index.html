    
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text RPG Adventure</title>
    <style>
        /* ==================== BASE STYLES ==================== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }
        
        /* ==================== LAYOUT ==================== */
        .game-container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }
        
        .sidebar {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            height: fit-content;
            position: sticky;
            top: 20px;
        }
        
        .main-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            min-height: 600px;
        }
        
        /* ==================== TYPOGRAPHY ==================== */
        h1 {
            color: #2a5298;
            margin-bottom: 20px;
            font-size: 2em;
        }
        
        h2 {
            color: #1e3c72;
            margin-bottom: 15px;
            font-size: 1.3em;
            border-bottom: 2px solid #2a5298;
            padding-bottom: 5px;
        }
        
        h3 {
            color: #2a5298;
            margin-top: 15px;
            margin-bottom: 10px;
        }
        
        /* ==================== STATS & SIDEBAR ==================== */
        .stat-group {
            margin-bottom: 20px;
        }
        
        .stat {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            padding: 8px;
            background: #f5f5f5;
            border-radius: 5px;
        }
        
        .stat-label {
            font-weight: bold;
            color: #555;
        }
        
        .stat-value {
            color: #2a5298;
            font-weight: bold;
        }
        
        .wounds {
            color: #c93838;
        }
        
        .skills-list, .inventory-list, .companions-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 8px;
        }
        
        .skill-tag, .item-tag, .companion-tag {
            background: #2a5298;
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.85em;
        }
        
        .item-tag {
            background: #5e8a3a;
        }
        
        .companion-tag {
            background: #8a3a7c;
            cursor: pointer;
        }
        
        .empty-slot {
            background: #ddd;
            color: #888;
        }
        
        .companion-details {
            background: #f5f5f5;
            padding: 10px;
            margin-top: 10px;
            border-radius: 5px;
            font-size: 0.9em;
        }
        
        /* ==================== BUTTONS ==================== */
        .shop-btn {
            width: 100%;
            background: #ffc107;
            color: #333;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            font-weight: bold;
            margin-bottom: 10px;
            transition: all 0.3s;
        }
        
        .shop-btn:hover {
            background: #ffb300;
        }
        
        .start-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 1.2em;
            cursor: pointer;
            margin-top: 20px;
        }
        
        .start-btn:hover {
            background: #218838;
        }
        
        .option-btn {
            background: #2a5298;
            color: white;
            border: none;
            padding: 15px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            text-align: left;
            transition: all 0.3s;
        }
        
        .option-btn:hover {
            background: #1e3c72;
            transform: translateX(5px);
        }
        
        .option-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        /* ==================== ENCOUNTERS ==================== */
        .encounter-text {
            background: #f9f9f9;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            line-height: 1.6;
            border-left: 4px solid #2a5298;
        }
        
        .options-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .start-screen {
            text-align: center;
        }
        
        /* ==================== LOG ==================== */
        .log-container {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid #ddd;
        }
        
        .log-entry {
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            border-left: 3px solid #2a5298;
        }
        
        .log-success {
            background: #d4edda;
            border-left-color: #28a745;
        }
        
        .log-warning {
            background: #fff3cd;
            border-left-color: #ffc107;
        }
        
        .log-danger {
            background: #f8d7da;
            border-left-color: #dc3545;
        }
        
        .log-info {
            background: #d1ecf1;
            border-left-color: #17a2b8;
        }
        
        /* ==================== MODALS ==================== */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            overflow: auto;
        }
        
        .modal-content {
            background: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 10px;
            max-width: 800px;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #2a5298;
            padding-bottom: 10px;
        }
        
        .close-btn {
            font-size: 2em;
            font-weight: bold;
            color: #aaa;
            cursor: pointer;
            border: none;
            background: none;
        }
        
        .close-btn:hover {
            color: #333;
        }
        
        /* ==================== SHOP ==================== */
        .shop-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .tab-btn {
            flex: 1;
            padding: 10px 20px;
            border: none;
            background: #ddd;
            cursor: pointer;
            border-radius: 5px;
            font-weight: bold;
        }
        
        .tab-btn.active {
            background: #2a5298;
            color: white;
        }
        
        .shop-items {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .shop-item {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #ddd;
        }
        
        .shop-item-name {
            font-weight: bold;
            color: #2a5298;
            margin-bottom: 5px;
        }
        
        .shop-item-desc {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 10px;
        }
        
        .shop-item-price {
            color: #ffc107;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .shop-item-btn {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .buy-btn {
            background: #28a745;
            color: white;
        }
        
        .buy-btn:hover {
            background: #218838;
        }
        
        .buy-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .sell-btn {
            background: #dc3545;
            color: white;
        }
        
        .sell-btn:hover {
            background: #c82333;
        }
        
        /* ==================== INVENTORY MANAGEMENT ==================== */
        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .character-inventory {
            background: #f9f9f9;
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #2a5298;
        }
        
        .character-inventory.player {
            border-color: #28a745;
        }
        
        .character-inventory h3 {
            margin-top: 0;
            color: #2a5298;
            border-bottom: 2px solid #2a5298;
            padding-bottom: 10px;
        }
        
        .inventory-items {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 15px;
        }
        
        .inventory-item-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: white;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        
        .inventory-item-name {
            font-weight: bold;
            color: #333;
            flex: 1;
        }
        
        .transfer-btn {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: bold;
            background: #2a5298;
            color: white;
            margin-left: 5px;
        }
        
        .transfer-btn:hover {
            background: #1e3c72;
        }
        
        .transfer-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .empty-inventory {
            text-align: center;
            color: #999;
            padding: 20px;
            font-style: italic;
        }
        
        /* ==================== DICE ROLL PANEL ==================== */
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .dice-result-panel {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 15px;
            margin: 20px 0;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.3s ease-out;
        }
        
        .dice-result-title {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 20px;
        }
        
        .dice-roll-display {
            font-size: 3em;
            margin: 20px 0;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .dice-calculation {
            font-size: 1.2em;
            margin: 15px 0;
            opacity: 0.9;
        }
        
        .dice-outcome {
            font-size: 2em;
            font-weight: bold;
            margin: 20px 0;
            padding: 15px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.2);
        }
        
        .dice-outcome.GS {
            background: rgba(40, 167, 69, 0.3);
        }
        
        .dice-outcome.MS {
            background: rgba(255, 193, 7, 0.3);
        }
        
        .dice-outcome.BS {
            background: rgba(220, 53, 69, 0.3);
        }
        
        .continue-btn {
            background: white;
            color: #667eea;
            border: none;
            padding: 15px 40px;
            border-radius: 8px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s;
        }
        
        .continue-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        /* ==================== LUCK PROMPT ==================== */
        .luck-prompt {
            background: #fff3cd;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 2px solid #ffc107;
        }
        
        .luck-btn {
            background: #ffc107;
            color: #333;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
            font-weight: bold;
        }
        
        .luck-btn:hover {
            background: #ffb300;
        }
        
        /* ==================== WOUND DISTRIBUTION ==================== */
        .wound-distribution-panel {
            background: linear-gradient(135deg, #c94b4b 0%, #4b134f 100%);
            color: white;
            padding: 30px;
            border-radius: 15px;
            margin: 20px 0;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.3s ease-out;
        }
        
        .wound-panel-title {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .wound-characters {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .wound-character-card {
            background: rgba(255, 255, 255, 0.15);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        .wound-character-name {
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 10px;
        }
        
        .wound-character-health {
            font-size: 0.9em;
            margin-bottom: 15px;
            opacity: 0.9;
        }
        
        .wound-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .wound-btn {
            background: rgba(255, 255, 255, 0.9);
            color: #c94b4b;
            border: none;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .wound-btn:hover:not(:disabled) {
            background: white;
            transform: scale(1.1);
        }
        
        .wound-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .wound-count {
            font-size: 1.5em;
            font-weight: bold;
            min-width: 40px;
            text-align: center;
        }
        
        .wound-remaining {
            text-align: center;
            font-size: 1.2em;
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
        }
        
        .wound-confirm-btn {
            background: white;
            color: #c94b4b;
            border: none;
            padding: 15px 40px;
            border-radius: 8px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            margin: 20px auto;
            display: block;
            transition: all 0.3s;
        }
        
        .wound-confirm-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .wound-confirm-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* ==================== ENCOUNTER SELECTOR ==================== */
        .encounter-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 500px;
            overflow-y: auto;
        }
        
        .encounter-list-item {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #ddd;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .encounter-list-item:hover {
            border-color: #2a5298;
            background: #e8f0ff;
            transform: translateX(5px);
        }
        
        .encounter-list-title {
            font-weight: bold;
            color: #2a5298;
            margin-bottom: 5px;
            font-size: 1.1em;
        }
        
        .encounter-list-preview {
            color: #666;
            font-size: 0.9em;
        }
        
        /* ==================== RESPONSIVE ==================== */
        @media (max-width: 768px) {
            .game-container {
                grid-template-columns: 1fr;
            }
            
            .sidebar {
                position: static;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="sidebar" id="sidebar">
            <h2>Player</h2>
            <div class="stat-group">
                <div class="stat">
                    <span class="stat-label">Wounds</span>
                    <span class="stat-value wounds" id="wounds">0/6</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Food</span>
                    <span class="stat-value" id="food">0</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Luck</span>
                    <span class="stat-value" id="luck">0</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Coins</span>
                    <span class="stat-value" id="coins">0</span>
                </div>
            </div>
            
            <h3>Skills</h3>
            <div class="skills-list" id="skills"></div>
            
            <h3>Inventory</h3>
            <div class="inventory-list" id="inventory"></div>
            
            <h3>Companions</h3>
            <div class="companions-list" id="companions"></div>
            
            <div id="companionDetails"></div>
            
            <button class="shop-btn" id="shopBtn" style="display: none;">🏪 Open Shop</button>
            <button class="shop-btn" id="inventoryBtn" style="background: #5e8a3a; display: none;">📦 Manage Inventory</button>
            <button class="shop-btn" id="debugBtn" style="background: #dc3545; display: none;">🐛 Add Companion</button>
            <button class="shop-btn" id="encounterBtn" style="background: #6610f2; display: none;">🎭 Launch Encounter</button>
        </div>
        
        <div class="main-panel" id="mainPanel">
            <div class="start-screen" id="startScreen">
                <h1>🗡️ Text RPG Adventure 🗡️</h1>
                <p>Embark on a perilous journey filled with danger, mystery, and adventure!</p>
                <button class="start-btn" id="startBtn">Begin Adventure</button>
            </div>
            
            <div id="gameContent" style="display: none;">
                <h1>Adventure Log</h1>
                <div id="encounterContainer"></div>
                <div class="log-container">
                    <h3>Recent Events</h3>
                    <div id="logContainer"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Shop Modal -->
    <div id="shopModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>🏪 Trading Post</h2>
                <button class="close-btn" id="closeShop">&times;</button>
            </div>
            <div class="shop-tabs">
                <button class="tab-btn active" id="buyTab">Buy Items</button>
                <button class="tab-btn" id="sellTab">Sell Items</button>
            </div>
            <div id="shopContent"></div>
        </div>
    </div>
    
    <!-- Inventory Management Modal -->
    <div id="inventoryModal" class="modal">
        <div class="modal-content" style="max-width: 1000px;">
            <div class="modal-header">
                <h2>📦 Inventory Management</h2>
                <button class="close-btn" id="closeInventory">&times;</button>
            </div>
            <div id="inventoryContent"></div>
        </div>
    </div>
    
    <!-- Encounter Selector Modal -->
    <div id="encounterModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>🎭 Select Encounter</h2>
                <button class="close-btn" id="closeEncounter">&times;</button>
            </div>
            <div id="encounterContent"></div>
        </div>
    </div>

    <script>
        // ==================== DATA: ITEMS ====================
        const ITEMS = {
            'Health Potion': { value: 10, description: 'Heals 2 wounds' },
            'Healing Water': { value: 8, description: 'Heals 1 wound' },
            'Lockpick Set': { value: 15, description: 'Useful for opening locked things' },
            'Rope': { value: 5, description: 'Always handy to have' },
            'Torch': { value: 3, description: 'Lights the way' },
            'Golden Coin': { value: 20, description: 'Valuable currency' },
            'Rations': { value: 5, description: 'Adds 2 food' },
            'Lucky Charm': { value: 25, description: 'Adds 1 luck' },
            'Smoke Bomb': { value: 12, description: 'Useful for escapes' },
            'Map': { value: 8, description: 'Shows nearby locations' },
            'Compass': { value: 10, description: 'Never get lost' },
            'Bandages': { value: 7, description: 'Heals 1 wound' },
            'Antidote': { value: 15, description: 'Cures poison' },
            'Tent': { value: 20, description: 'Safe rest spot' },
            'Fishing Rod': { value: 12, description: 'Catch fish for food' },
            'Stolen Goods': { value: 15, description: 'Questionable origin' },
            'Broken Treasure': { value: 5, description: 'Damaged but valuable' },
            'Sword': { value: 30, description: '+1 to combat rolls' },
            'Shield': { value: 25, description: 'Reduces damage' },
            'Bow': { value: 28, description: 'Ranged weapon' }
        };
        
        // ==================== DATA: SKILLS ====================
        const SKILLS = [
            'Acrobatics', 'Silent Movement', 'Good Fortune', 'Charisma', 
            'Pickpocketing', 'Healing', 'Disguise', 'Combat Training', 
            'Escapism', 'Strategy', 'Lockpicking', 'Ingenuity', 
            'Perception', 'Survival', 'Animal Handling'
        ];
        
        // ==================== MODEL: CHARACTER ====================
        class Character {
            constructor(name = 'Player', maxWounds = 6, maxInventory = 6, maxSkills = 6) {
                this.name = name;
                this.wounds = 0;
                this.maxWounds = maxWounds;
                this.food = 0;
                this.luck = 0;
                this.coins = 0;
                this.skills = [];
                this.maxSkills = maxSkills;
                this.inventory = [];
                this.maxInventory = maxInventory;
            }
            
            takeWounds(amount) {
                this.wounds = Math.min(this.wounds + amount, this.maxWounds);
                return this.wounds >= this.maxWounds;
            }
            
            canTakeWounds(amount) {
                return (this.wounds + amount) <= this.maxWounds;
            }
            
            getRemainingWounds() {
                return this.maxWounds - this.wounds;
            }
            
            healWounds(amount) {
                this.wounds = Math.max(0, this.wounds - amount);
            }
            
            addFood(amount) {
                this.food += amount;
            }
            
            removeFood(amount) {
                this.food = Math.max(0, this.food - amount);
                return this.food;
            }
            
            addLuck(amount) {
                this.luck += amount;
            }
            
            useLuck() {
                if (this.luck > 0) {
                    this.luck--;
                    return true;
                }
                return false;
            }
            
            addCoins(amount) {
                this.coins += amount;
            }
            
            removeCoins(amount) {
                if (this.coins >= amount) {
                    this.coins -= amount;
                    return true;
                }
                return false;
            }
            
            addSkill(skill) {
                if (this.skills.length < this.maxSkills && !this.skills.includes(skill)) {
                    this.skills.push(skill);
                    return true;
                }
                return false;
            }
            
            hasSkill(skill) {
                return this.skills.includes(skill);
            }
            
            addToInventory(item) {
                if (this.inventory.length < this.maxInventory) {
                    this.inventory.push(item);
                    return true;
                }
                return false;
            }
            
            removeFromInventory(item) {
                const index = this.inventory.indexOf(item);
                if (index > -1) {
                    this.inventory.splice(index, 1);
                    return true;
                }
                return false;
            }
            
            hasItem(item) {
                return this.inventory.includes(item);
            }
            
            isDead() {
                return this.wounds >= this.maxWounds;
            }
        }
        
        // ==================== MODEL: GAME STATE ====================
        class GameState {
            constructor() {
                this.player = new Character('Player', 6, 6, 6);
                this.companions = [];
                this.log = [];
                this.currentEncounter = null;
                this.pendingRoll = null;
                this.showingRollResult = false;
                this.pendingWounds = null;
                this.woundDistribution = {};
            }
            
            addCompanion(companion) {
                this.companions.push(companion);
            }
            
            removeCompanion(companion) {
                const index = this.companions.indexOf(companion);
                if (index > -1) {
                    this.companions.splice(index, 1);
                }
            }
            
            addLog(message, type = 'info') {
                this.log.unshift({ message, type, timestamp: Date.now() });
                if (this.log.length > 20) this.log.pop();
            }
            
            roll(difficulty, skill = null, useLuck = false) {
                const d20 = Math.floor(Math.random() * 20) + 1;
                let bonus = 0;
                
                if (skill && this.player.hasSkill(skill)) {
                    bonus += 1;
                }
                
                if (useLuck && this.player.useLuck()) {
                    bonus += 1;
                }
                
                const result = d20 + bonus - difficulty;
                
                let outcome;
                if (result >= 0) {
                    outcome = 'GS';
                } else if (result >= -5) {
                    outcome = 'MS';
                } else {
                    outcome = 'BS';
                }
                
                this.addLog(`🎲 Rolled ${d20} + ${bonus} - ${difficulty} = ${result} (${outcome})`, 
                    outcome === 'GS' ? 'success' : outcome === 'MS' ? 'warning' : 'danger');
                
                return { roll: d20, bonus, difficulty, result, outcome };
            }
        }
        
        // ==================== MODEL: ENCOUNTER ====================
        class Encounter {
            constructor(id, text, options) {
                this.id = id;
                this.text = text;
                this.options = options;
            }
        }
        
        class EncounterOption {
            constructor(text, action) {
                this.text = text;
                this.action = action;
            }
        }
        
        // ==================== ENCOUNTER: ACTION CREATORS ====================
        const Actions = {
            genericFight: (difficulty, skill = 'Combat Training') => {
                return (game) => {
                    game.state.pendingRoll = {
                        difficulty,
                        skill,
                        onResult: (outcome) => {
                            if (outcome === 'GS') {
                                game.state.addLog('⚔️ Victory! You defeated your enemy!', 'success');
                                game.checkGameOver();
                                game.nextEncounter();
                            } else if (outcome === 'MS') {
                                game.distributeWounds(1, () => {
                                    game.state.addLog('⚔️ Victory, but wounds were taken in the fight.', 'warning');
                                    game.checkGameOver();
                                    game.nextEncounter();
                                });
                            } else {
                                game.distributeWounds(3, () => {
                                    game.state.addLog('⚔️ Victory, but heavy wounds were taken in the brutal fight!', 'danger');
                                    game.checkGameOver();
                                    game.nextEncounter();
                                });
                            }
                        }
                    };
                    game.promptForLuck();
                };
            },
            
            skillCheck: (difficulty, skill, outcomes) => {
                return (game) => {
                    game.state.pendingRoll = {
                        difficulty,
                        skill,
                        onResult: (outcome) => {
                            if (outcomes[outcome]) {
                                outcomes[outcome](game);
                            }
                            game.checkGameOver();
                            game.nextEncounter();
                        }
                    };
                    game.promptForLuck();
                };
            },
            
            direct: (callback) => {
                return (game) => {
                    callback(game);
                    game.nextEncounter();
                };
            }
        };
        
        // ==================== DATA: ENCOUNTERS ====================
        const ENCOUNTERS = [
            new Encounter(
                'bear',
                'You encounter a massive bear blocking your path through the forest. Its eyes watch you carefully.',
                [
                    new EncounterOption('⚔️ Fight the bear!', Actions.genericFight(16, 'Combat Training')),
                    new EncounterOption('🐻 Try to pacify the bear', Actions.skillCheck(14, 'Animal Handling', {
                        'GS': (game) => {
                            const bear = new Character('Bear Companion', 3, 3, 1);
                            bear.addSkill('Combat Training');
                            game.state.addCompanion(bear);
                            game.state.addLog('🐻 The bear nuzzles you gently and joins your party!', 'success');
                        },
                        'MS': (game) => {
                            game.distributeWounds(1, () => {
                                game.state.addLog('🐻 The bear swipes at you before running away.', 'warning');
                            });
                        },
                        'BS': (game) => {
                            game.distributeWounds(1, () => {
                                game.state.addLog('🐻 The bear attacks! You must fight!', 'danger');
                                Actions.genericFight(16, 'Combat Training')(game);
                            });
                        }
                    })),
                    new EncounterOption('🏃 Run away', Actions.direct((game) => {
                        game.state.addLog('You flee from the bear and continue on your journey.', 'info');
                    }))
                ]
            ),
            
            new Encounter(
                'merchant',
                'A traveling merchant approaches you with a friendly smile. "Looking to trade?"',
                [
                    new EncounterOption('🍞 Buy food (costs 1 luck)', Actions.direct((game) => {
                        if (game.state.player.luck > 0) {
                            game.state.player.useLuck();
                            game.state.player.addFood(3);
                            game.state.addLog('Purchased 3 food for 1 luck.', 'success');
                        } else {
                            game.state.addLog('Not enough luck!', 'danger');
                        }
                    })),
                    new EncounterOption('🗡️ Rob the merchant', Actions.skillCheck(15, 'Pickpocketing', {
                        'GS': (game) => {
                            game.state.player.addFood(2);
                            game.state.player.addLuck(1);
                            game.state.player.addToInventory('Stolen Goods');
                            game.state.addLog('Successfully robbed the merchant! Gained food, luck, and items.', 'success');
                        },
                        'MS': (game) => {
                            game.state.player.addFood(1);
                            game.state.addLog('You got some food, but the merchant noticed you!', 'warning');
                        },
                        'BS': (game) => {
                            game.distributeWounds(2, () => {
                                game.state.addLog('The merchant\'s guards caught you!', 'danger');
                            });
                        }
                    })),
                    new EncounterOption('👋 Leave peacefully', Actions.direct((game) => {
                        game.state.addLog('You wave goodbye to the merchant.', 'info');
                    }))
                ]
            ),
            
            new Encounter(
                'locked_chest',
                'You discover an old locked chest partially buried in the ground.',
                [
                    new EncounterOption('🔓 Pick the lock', Actions.skillCheck(12, 'Lockpicking', {
                        'GS': (game) => {
                            game.state.player.addLuck(2);
                            game.state.player.addToInventory('Golden Coin');
                            game.state.addLog('Successfully picked the lock! Found luck and treasure!', 'success');
                        },
                        'MS': (game) => {
                            game.state.player.addLuck(1);
                            game.state.addLog('You managed to open it, but your lockpick broke.', 'warning');
                        },
                        'BS': (game) => {
                            game.distributeWounds(1, () => {
                                game.state.addLog('The chest was trapped! It exploded.', 'danger');
                            });
                        }
                    })),
                    new EncounterOption('💪 Smash it open', Actions.direct((game) => {
                        const outcome = Math.random();
                        if (outcome > 0.5) {
                            game.state.player.addToInventory('Broken Treasure');
                            game.state.addLog('You smashed it open and found some broken items.', 'warning');
                        } else {
                            game.distributeWounds(1, () => {
                                game.state.addLog('The chest was too sturdy. You hurt yourself.', 'danger');
                            });
                        }
                    })),
                    new EncounterOption('🚶 Leave it', Actions.direct((game) => {
                        game.state.addLog('You decide not to risk it and continue on.', 'info');
                    }))
                ]
            ),
            
            new Encounter(
                'bandit',
                'A bandit jumps out from behind a tree! "Your gold or your life!"',
                [
                    new EncounterOption('⚔️ Fight!', Actions.genericFight(14, 'Combat Training')),
                    new EncounterOption('💰 Give 2 food', Actions.direct((game) => {
                        if (game.state.player.food >= 2) {
                            game.state.player.removeFood(2);
                            game.state.addLog('You gave the bandit food and he let you pass.', 'warning');
                        } else {
                            game.state.addLog('You don\'t have enough food! The bandit attacks!', 'danger');
                            Actions.genericFight(14, 'Combat Training')(game);
                        }
                    })),
                    new EncounterOption('🗣️ Persuade them', Actions.skillCheck(13, 'Charisma', {
                        'GS': (game) => {
                            game.state.player.addLuck(1);
                            game.state.addLog('You convinced the bandit to join a better path. They gave you a token of thanks!', 'success');
                        },
                        'MS': (game) => {
                            game.state.addLog('The bandit lets you go, but keeps your supplies.', 'warning');
                        },
                        'BS': (game) => {
                            game.state.addLog('Your words angered the bandit!', 'danger');
                            Actions.genericFight(14, 'Combat Training')(game);
                        }
                    }))
                ]
            ),
            
            new Encounter(
                'healing_spring',
                'You discover a crystal-clear spring with mystical properties.',
                [
                    new EncounterOption('💧 Drink from the spring', Actions.direct((game) => {
                        game.state.player.healWounds(2);
                        game.state.addLog('The spring heals 2 wounds!', 'success');
                    })),
                    new EncounterOption('🍼 Fill your waterskin', Actions.direct((game) => {
                        game.state.player.addToInventory('Healing Water');
                        game.state.addLog('You fill a container with healing water.', 'success');
                    })),
                    new EncounterOption('🚶 Move on', Actions.direct((game) => {
                        game.state.addLog('You continue your journey.', 'info');
                    }))
                ]
            ),
            
            new Encounter(
                'mysterious_stranger',
                'A hooded figure approaches you. "I sense potential in you, traveler."',
                [
                    new EncounterOption('📚 Learn a skill', Actions.direct((game) => {
                        const availableSkills = SKILLS.filter(s => !game.state.player.hasSkill(s));
                        if (availableSkills.length > 0 && game.state.player.skills.length < 6) {
                            const randomSkill = availableSkills[Math.floor(Math.random() * availableSkills.length)];
                            game.state.player.addSkill(randomSkill);
                            game.state.addLog(`You learned ${randomSkill}!`, 'success');
                        } else {
                            game.state.addLog('You already know too many skills.', 'warning');
                        }
                    })),
                    new EncounterOption('✨ Receive luck', Actions.direct((game) => {
                        game.state.player.addLuck(2);
                        game.state.addLog('The stranger blessed you with 2 luck!', 'success');
                    })),
                    new EncounterOption('❌ Refuse', Actions.direct((game) => {
                        game.state.addLog('You politely decline and move on.', 'info');
                    }))
                ]
            )
        ];
        
        // ==================== ENGINE: GAME ====================
        class Game {
            constructor() {
                this.state = new GameState();
                this.encounterHistory = [];
            }
            
            startGame() {
                // Initialize player
                this.state.player.addSkill('Combat Training');
                this.state.player.addSkill('Survival');
                this.state.player.addFood(3);
                this.state.player.addLuck(2);
                this.state.player.addCoins(50);
                
                document.getElementById('startScreen').style.display = 'none';
                document.getElementById('gameContent').style.display = 'block';
                
                // Show sidebar buttons
                document.getElementById('shopBtn').style.display = 'block';
                document.getElementById('inventoryBtn').style.display = 'block';
                document.getElementById('debugBtn').style.display = 'block';
                document.getElementById('encounterBtn').style.display = 'block';
                
                this.state.addLog('🎮 Your adventure begins!', 'success');
                this.nextEncounter();
                this.render();
            }
            
            nextEncounter() {
                const availableEncounters = ENCOUNTERS.filter(e => 
                    !this.encounterHistory.includes(e.id) || this.encounterHistory.length >= ENCOUNTERS.length
                );
                
                const encounter = availableEncounters[Math.floor(Math.random() * availableEncounters.length)];
                this.loadEncounter(encounter);
            }
            
            loadEncounter(encounter) {
                this.encounterHistory.push(encounter.id);
                
                if (this.encounterHistory.length > 10) {
                    this.encounterHistory.shift();
                }
                
                this.state.currentEncounter = encounter;
                this.render();
            }
            
            promptForLuck() {
                if (this.state.player.luck > 0 && this.state.pendingRoll) {
                    this.renderLuckPrompt();
                } else {
                    this.executeRoll(false);
                }
            }
            
            executeRoll(useLuck) {
                if (!this.state.pendingRoll) return;
                
                const { difficulty, skill, onResult } = this.state.pendingRoll;
                const rollResult = this.state.roll(difficulty, skill, useLuck);
                
                // Store the roll result and callback for later
                this.state.rollResult = rollResult;
                this.state.rollCallback = onResult;
                this.state.showingRollResult = true;
                
                // Show the dice result panel
                this.render();
            }
            
            continueAfterRoll() {
                if (!this.state.rollResult || !this.state.rollCallback) return;
                
                // Execute the callback with the outcome
                this.state.rollCallback(this.state.rollResult.outcome);
                
                // Clear the roll state
                this.state.pendingRoll = null;
                this.state.rollResult = null;
                this.state.rollCallback = null;
                this.state.showingRollResult = false;
                
                this.render();
            }
            
            checkGameOver() {
                if (this.state.player.isDead()) {
                    this.state.addLog('💀 You have died! Game Over!', 'danger');
                    alert('Game Over! You have died.');
                    location.reload();
                }
            }
            
            distributeWounds(amount, callback) {
                // If no companions, just apply to player directly
                if (this.state.companions.length === 0) {
                    this.state.player.takeWounds(amount);
                    if (callback) callback();
                    this.render();
                    return;
                }
                
                // Store pending wounds and callback
                this.state.pendingWounds = amount;
                this.state.woundCallback = callback;
                
                // Initialize distribution (all to player by default)
                this.state.woundDistribution = { player: amount };
                this.state.companions.forEach((c, idx) => {
                    this.state.woundDistribution[`companion-${idx}`] = 0;
                });
                
                this.render();
            }
            
            adjustWoundDistribution(characterId, delta) {
                const char = characterId === 'player' 
                    ? this.state.player 
                    : this.state.companions[parseInt(characterId.split('-')[1])];
                
                const currentAssigned = this.state.woundDistribution[characterId] || 0;
                const newAssigned = currentAssigned + delta;
                
                // Check if character can handle the wounds
                if (delta > 0) {
                    if (!char.canTakeWounds(newAssigned)) {
                        return; // Can't add more wounds
                    }
                    
                    // Check if we have wounds left to distribute
                    const totalAssigned = Object.values(this.state.woundDistribution).reduce((a, b) => a + b, 0);
                    if (totalAssigned >= this.state.pendingWounds) {
                        return; // No more wounds to distribute
                    }
                }
                
                if (newAssigned >= 0) {
                    this.state.woundDistribution[characterId] = newAssigned;
                    this.render();
                }
            }
            
            confirmWoundDistribution() {
                // Apply wounds to all characters
                const playerWounds = this.state.woundDistribution['player'] || 0;
                this.state.player.takeWounds(playerWounds);
                
                this.state.companions.forEach((companion, idx) => {
                    const wounds = this.state.woundDistribution[`companion-${idx}`] || 0;
                    companion.takeWounds(wounds);
                });
                
                // Log the distribution
                Object.entries(this.state.woundDistribution).forEach(([id, wounds]) => {
                    if (wounds > 0) {
                        const name = id === 'player' 
                            ? 'Player' 
                            : this.state.companions[parseInt(id.split('-')[1])].name;
                        this.state.addLog(`${name} took ${wounds} wound${wounds > 1 ? 's' : ''}`, 'danger');
                    }
                });
                
                // Clear pending wounds
                const callback = this.state.woundCallback;
                this.state.pendingWounds = null;
                this.state.woundCallback = null;
                this.state.woundDistribution = {};
                
                // Execute callback if provided
                if (callback) {
                    callback();
                }
                
                this.render();
            }
            
            // Shop methods
            openShop() {
                document.getElementById('shopModal').style.display = 'block';
                this.renderShop('buy');
            }
            
            closeShop() {
                document.getElementById('shopModal').style.display = 'none';
            }
            
            renderShop(tab) {
                const content = document.getElementById('shopContent');
                
                if (tab === 'buy') {
                    const availableItems = Object.entries(ITEMS).filter(([name]) => 
                        !this.state.player.inventory.includes(name) || 
                        ['Health Potion', 'Rations', 'Bandages', 'Healing Water'].includes(name)
                    );
                    
                    content.innerHTML = `
                        <div class="shop-items">
                            ${availableItems.map(([name, item]) => `
                                <div class="shop-item">
                                    <div class="shop-item-name">${name}</div>
                                    <div class="shop-item-desc">${item.description}</div>
                                    <div class="shop-item-price">💰 ${item.value} coins</div>
                                    <button class="shop-item-btn buy-btn" data-item="${name}" data-price="${item.value}"
                                        ${this.state.player.coins < item.value || this.state.player.inventory.length >= this.state.player.maxInventory ? 'disabled' : ''}>
                                        Buy
                                    </button>
                                </div>
                            `).join('')}
                        </div>
                    `;
                    
                    document.querySelectorAll('.buy-btn').forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            const itemName = e.target.getAttribute('data-item');
                            const price = parseInt(e.target.getAttribute('data-price'));
                            this.buyItem(itemName, price);
                        });
                    });
                } else {
                    content.innerHTML = `
                        <div class="shop-items">
                            ${this.state.player.inventory.map(itemName => {
                                const item = ITEMS[itemName];
                                const sellPrice = Math.floor(item.value * 0.6);
                                return `
                                    <div class="shop-item">
                                        <div class="shop-item-name">${itemName}</div>
                                        <div class="shop-item-desc">${item.description}</div>
                                        <div class="shop-item-price">💰 ${sellPrice} coins</div>
                                        <button class="shop-item-btn sell-btn" data-item="${itemName}" data-price="${sellPrice}">
                                            Sell
                                        </button>
                                    </div>
                                `;
                            }).join('') || '<p style="text-align: center; padding: 20px;">No items to sell</p>'}
                        </div>
                    `;
                    
                    document.querySelectorAll('.sell-btn').forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            const itemName = e.target.getAttribute('data-item');
                            const price = parseInt(e.target.getAttribute('data-price'));
                            this.sellItem(itemName, price);
                        });
                    });
                }
            }
            
            buyItem(itemName, price) {
                if (this.state.player.coins >= price) {
                    if (this.state.player.addToInventory(itemName)) {
                        this.state.player.removeCoins(price);
                        this.state.addLog(`Bought ${itemName} for ${price} coins.`, 'success');
                        this.render();
                        this.renderShop('buy');
                    } else {
                        this.state.addLog('Inventory is full!', 'danger');
                    }
                } else {
                    this.state.addLog('Not enough coins!', 'danger');
                }
            }
            
            sellItem(itemName, price) {
                if (this.state.player.removeFromInventory(itemName)) {
                    this.state.player.addCoins(price);
                    this.state.addLog(`Sold ${itemName} for ${price} coins.`, 'success');
                    this.render();
                    this.renderShop('sell');
                }
            }
            
            // Inventory management methods
            openInventory() {
                document.getElementById('inventoryModal').style.display = 'block';
                this.renderInventoryManagement();
            }
            
            closeInventory() {
                document.getElementById('inventoryModal').style.display = 'none';
            }
            
            renderInventoryManagement() {
                const content = document.getElementById('inventoryContent');
                
                // Create a list of all characters (player + companions)
                const allCharacters = [
                    { char: this.state.player, name: 'Player', isPlayer: true },
                    ...this.state.companions.map((c, idx) => ({ char: c, name: c.name, idx, isPlayer: false }))
                ];
                
                content.innerHTML = `
                    <div class="inventory-grid">
                        ${allCharacters.map((charData) => {
                            const { char, name, isPlayer } = charData;
                            return `
                                <div class="character-inventory ${isPlayer ? 'player' : ''}">
                                    <h3>${isPlayer ? '👤 ' : '🤝 '}${name}</h3>
                                    <div style="font-size: 0.9em; color: #666; margin-bottom: 10px;">
                                        Slots: ${char.inventory.length}/${char.maxInventory}
                                    </div>
                                    <div class="inventory-items" id="inv-${isPlayer ? 'player' : charData.idx}">
                                        ${char.inventory.length === 0 ? 
                                            '<div class="empty-inventory">No items</div>' :
                                            char.inventory.map((item, itemIdx) => `
                                                <div class="inventory-item-row">
                                                    <span class="inventory-item-name">${item}</span>
                                                    <div>
                                                        ${allCharacters.filter(other => 
                                                            (isPlayer ? !other.isPlayer : other.isPlayer || other.idx !== charData.idx)
                                                        ).map(targetChar => {
                                                            const targetId = targetChar.isPlayer ? 'player' : targetChar.idx;
                                                            const targetName = targetChar.isPlayer ? 'Player' : targetChar.name;
                                                            const canTransfer = targetChar.char.inventory.length < targetChar.char.maxInventory;
                                                            return `
                                                                <button 
                                                                    class="transfer-btn" 
                                                                    data-from="${isPlayer ? 'player' : charData.idx}"
                                                                    data-to="${targetId}"
                                                                    data-item="${item}"
                                                                    ${!canTransfer ? 'disabled' : ''}
                                                                    title="Transfer to ${targetName}">
                                                                    → ${targetChar.isPlayer ? '👤' : targetChar.name.substring(0, 2)}
                                                                </button>
                                                            `;
                                                        }).join('')}
                                                    </div>
                                                </div>
                                            `).join('')
                                        }
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
                
                // Add event listeners to all transfer buttons
                document.querySelectorAll('.transfer-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const fromId = e.target.getAttribute('data-from');
                        const toId = e.target.getAttribute('data-to');
                        const item = e.target.getAttribute('data-item');
                        this.transferItem(fromId, toId, item);
                    });
                });
            }
            
            transferItem(fromId, toId, itemName) {
                let fromChar, toChar;
                
                // Get source character
                if (fromId === 'player') {
                    fromChar = this.state.player;
                } else {
                    fromChar = this.state.companions[parseInt(fromId)];
                }
                
                // Get destination character
                if (toId === 'player') {
                    toChar = this.state.player;
                } else {
                    toChar = this.state.companions[parseInt(toId)];
                }
                
                // Check if destination has space
                if (toChar.inventory.length >= toChar.maxInventory) {
                    this.state.addLog(`${toChar.name}'s inventory is full!`, 'danger');
                    return;
                }
                
                // Transfer the item
                if (fromChar.removeFromInventory(itemName)) {
                    if (toChar.addToInventory(itemName)) {
                        this.state.addLog(`Transferred ${itemName} from ${fromChar.name} to ${toChar.name}`, 'success');
                        this.render();
                        this.renderInventoryManagement();
                    } else {
                        // Rollback if add fails
                        fromChar.addToInventory(itemName);
                        this.state.addLog(`Failed to transfer ${itemName}`, 'danger');
                    }
                }
            }
            
            // Debug methods
            debugAddCompanion() {
                const companionNames = [
                    'Brave Knight', 'Wise Mage', 'Swift Rogue', 'Holy Cleric',
                    'Fierce Warrior', 'Cunning Thief', 'Noble Paladin', 'Wild Ranger',
                    'Mysterious Assassin', 'Friendly Bard', 'Ancient Druid', 'Battle Monk'
                ];
                
                const randomName = companionNames[Math.floor(Math.random() * companionNames.length)];
                const companion = new Character(randomName, 3, 3, 1);
                
                const randomSkill = SKILLS[Math.floor(Math.random() * SKILLS.length)];
                companion.addSkill(randomSkill);
                
                this.state.addCompanion(companion);
                this.state.addLog(`${randomName} with ${randomSkill} skill has joined your party!`, 'success');
                this.render();
            }
            
            openEncounterSelector() {
                document.getElementById('encounterModal').style.display = 'block';
                this.renderEncounterSelector();
            }
            
            closeEncounterSelector() {
                document.getElementById('encounterModal').style.display = 'none';
            }
            
            renderEncounterSelector() {
                const content = document.getElementById('encounterContent');
                
                content.innerHTML = `
                    <div class="encounter-list">
                        ${ENCOUNTERS.map((encounter, idx) => `
                            <div class="encounter-list-item" data-encounter-id="${encounter.id}">
                                <div class="encounter-list-title">
                                    ${encounter.id.split('_').map(word => 
                                        word.charAt(0).toUpperCase() + word.slice(1)
                                    ).join(' ')}
                                </div>
                                <div class="encounter-list-preview">
                                    ${encounter.text.substring(0, 100)}${encounter.text.length > 100 ? '...' : ''}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
                
                // Add click listeners
                document.querySelectorAll('.encounter-list-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        const encounterId = e.currentTarget.getAttribute('data-encounter-id');
                        this.launchSpecificEncounter(encounterId);
                    });
                });
            }
            
            launchSpecificEncounter(encounterId) {
                const encounter = ENCOUNTERS.find(e => e.id === encounterId);
                if (encounter) {
                    this.closeEncounterSelector();
                    this.state.addLog(`🎭 Launching encounter: ${encounterId}`, 'info');
                    this.loadEncounter(encounter);
                }
            }
            
            // Main render method
            render() {
                this.renderStats();
                this.renderEncounter();
                this.renderLog();
            }
            
            renderStats() {
                document.getElementById('wounds').textContent = `${this.state.player.wounds}/${this.state.player.maxWounds}`;
                document.getElementById('food').textContent = this.state.player.food;
                document.getElementById('luck').textContent = this.state.player.luck;
                document.getElementById('coins').textContent = this.state.player.coins;
                
                const skillsEl = document.getElementById('skills');
                skillsEl.innerHTML = this.state.player.skills.map(s => 
                    `<span class="skill-tag">${s}</span>`
                ).join('') || '<span class="skill-tag empty-slot">No skills</span>';
                
                const invEl = document.getElementById('inventory');
                const invSlots = [...this.state.player.inventory];
                while (invSlots.length < this.state.player.maxInventory) {
                    invSlots.push(null);
                }
                invEl.innerHTML = invSlots.map(i => 
                    i ? `<span class="item-tag">${i}</span>` : '<span class="item-tag empty-slot">Empty</span>'
                ).join('');
                
                const compEl = document.getElementById('companions');
                compEl.innerHTML = this.state.companions.map((c, idx) => 
                    `<span class="companion-tag" data-idx="${idx}">${c.name}</span>`
                ).join('') || '<span class="companion-tag empty-slot">No companions</span>';
                
                // Add event listeners for companion tags
                document.querySelectorAll('.companion-tag[data-idx]').forEach(tag => {
                    tag.addEventListener('click', (e) => {
                        const idx = parseInt(e.target.getAttribute('data-idx'));
                        this.showCompanionDetails(idx);
                    });
                });
            }
            
            showCompanionDetails(index) {
                const companion = this.state.companions[index];
                const detailsEl = document.getElementById('companionDetails');
                detailsEl.innerHTML = `
                    <div class="companion-details">
                        <strong>${companion.name}</strong><br>
                        Wounds: ${companion.wounds}/${companion.maxWounds}<br>
                        Skills: ${companion.skills.join(', ')}<br>
                        Inventory: ${companion.inventory.join(', ') || 'Empty'}
                    </div>
                `;
            }
            
            renderEncounter() {
                const container = document.getElementById('encounterContainer');
                container.innerHTML = '';
                
                if (!this.state.currentEncounter) return;
                
                // Show wound distribution panel if pending
                if (this.state.pendingWounds !== null) {
                    this.renderWoundDistribution(container);
                    return;
                }
                
                // Show dice result panel if we're showing roll results
                if (this.state.showingRollResult && this.state.rollResult) {
                    this.renderDiceResult(container);
                    return;
                }
                
                const textDiv = document.createElement('div');
                textDiv.className = 'encounter-text';
                textDiv.textContent = this.state.currentEncounter.text;
                container.appendChild(textDiv);
                
                if (!this.state.pendingRoll) {
                    const optionsDiv = document.createElement('div');
                    optionsDiv.className = 'options-container';
                    
                    this.state.currentEncounter.options.forEach((option, idx) => {
                        const btn = document.createElement('button');
                        btn.className = 'option-btn';
                        btn.textContent = option.text;
                        btn.addEventListener('click', () => option.action(this));
                        optionsDiv.appendChild(btn);
                    });
                    
                    container.appendChild(optionsDiv);
                }
            }
            
            renderDiceResult(container) {
                const { roll, bonus, difficulty, result, outcome } = this.state.rollResult;
                const { skill } = this.state.pendingRoll;
                
                const outcomeText = {
                    'GS': '✨ GREAT SUCCESS! ✨',
                    'MS': '⚠️ Medium Success ⚠️',
                    'BS': '❌ Bad Success ❌'
                };
                
                const panel = document.createElement('div');
                panel.className = 'dice-result-panel';
                panel.innerHTML = `
                    <div class="dice-result-title">🎲 Dice Roll Result 🎲</div>
                    ${skill ? `<div style="font-size: 1.1em; margin-bottom: 10px;">Skill Check: ${skill}</div>` : ''}
                    <div class="dice-roll-display">🎲 ${roll}</div>
                    <div class="dice-calculation">
                        ${roll} (roll) ${bonus > 0 ? `+ ${bonus} (bonus)` : ''} - ${difficulty} (difficulty) = ${result}
                    </div>
                    <div class="dice-outcome ${outcome}">
                        ${outcomeText[outcome]}
                    </div>
                    <button class="continue-btn" id="continueBtn">Continue →</button>
                `;
                
                container.appendChild(panel);
                
                // Add event listener to continue button
                document.getElementById('continueBtn').addEventListener('click', () => {
                    this.continueAfterRoll();
                });
            }
            
            renderLuckPrompt() {
                const container = document.getElementById('encounterContainer');
                const prompt = document.createElement('div');
                prompt.className = 'luck-prompt';
                prompt.innerHTML = `
                    <strong>🍀 Use a Luck Point?</strong>
                    <p>You have ${this.state.player.luck} luck remaining. Using luck gives you +1 to your roll.</p>
                    <button class="luck-btn" id="useLuckBtn">Use Luck (+1)</button>
                    <button class="luck-btn" id="noLuckBtn">Don't Use Luck</button>
                `;
                container.appendChild(prompt);
                
                document.getElementById('useLuckBtn').addEventListener('click', () => this.executeRoll(true));
                document.getElementById('noLuckBtn').addEventListener('click', () => this.executeRoll(false));
            }
            
            renderWoundDistribution(container) {
                const allCharacters = [
                    { char: this.state.player, id: 'player', name: 'Player (You)' },
                    ...this.state.companions.map((c, idx) => ({ 
                        char: c, 
                        id: `companion-${idx}`, 
                        name: c.name 
                    }))
                ];
                
                const totalAssigned = Object.values(this.state.woundDistribution).reduce((a, b) => a + b, 0);
                const remaining = this.state.pendingWounds - totalAssigned;
                
                const panel = document.createElement('div');
                panel.className = 'wound-distribution-panel';
                panel.innerHTML = `
                    <div class="wound-panel-title">💔 Distribute ${this.state.pendingWounds} Wound${this.state.pendingWounds > 1 ? 's' : ''}</div>
                    <div class="wound-remaining">
                        Wounds to distribute: <strong>${remaining}</strong>
                    </div>
                    <div class="wound-characters">
                        ${allCharacters.map(({ char, id, name }) => {
                            const assigned = this.state.woundDistribution[id] || 0;
                            const currentWounds = char.wounds;
                            const maxWounds = char.maxWounds;
                            const canAdd = (currentWounds + assigned) < maxWounds && remaining > 0;
                            const canRemove = assigned > 0;
                            
                            return `
                                <div class="wound-character-card">
                                    <div class="wound-character-name">${name}</div>
                                    <div class="wound-character-health">
                                        Current: ${currentWounds}/${maxWounds}<br>
                                        After: ${currentWounds + assigned}/${maxWounds}
                                    </div>
                                    <div class="wound-controls">
                                        <button class="wound-btn" data-action="remove" data-id="${id}" ${!canRemove ? 'disabled' : ''}>−</button>
                                        <div class="wound-count">${assigned}</div>
                                        <button class="wound-btn" data-action="add" data-id="${id}" ${!canAdd ? 'disabled' : ''}>+</button>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                    <button class="wound-confirm-btn" id="confirmWounds" ${remaining !== 0 ? 'disabled' : ''}>
                        ${remaining === 0 ? 'Confirm Distribution' : `Assign ${remaining} more wound${remaining !== 1 ? 's' : ''}`}
                    </button>
                `;
                
                container.appendChild(panel);
                
                // Add event listeners
                document.querySelectorAll('.wound-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const action = e.target.getAttribute('data-action');
                        const id = e.target.getAttribute('data-id');
                        this.adjustWoundDistribution(id, action === 'add' ? 1 : -1);
                    });
                });
                
                const confirmBtn = document.getElementById('confirmWounds');
                if (confirmBtn) {
                    confirmBtn.addEventListener('click', () => {
                        this.confirmWoundDistribution();
                    });
                }
            }
            
            renderLog() {
                const logEl = document.getElementById('logContainer');
                logEl.innerHTML = this.state.log.slice(0, 10).map(entry => 
                    `<div class="log-entry log-${entry.type}">${entry.message}</div>`
                ).join('');
            }
        }
        
        // ==================== INITIALIZATION ====================
        let game;
        
        // Wait for DOM to be ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initGame);
        } else {
            initGame();
        }
        
        function initGame() {
            game = new Game();
            
            // Start button
            const startBtn = document.getElementById('startBtn');
            if (startBtn) {
                startBtn.addEventListener('click', () => {
                    game.startGame();
                    setTimeout(setupGameButtons, 100);
                });
            }
            
            setupModalListeners();
        }
        
        function setupGameButtons() {
            const shopBtn = document.getElementById('shopBtn');
            if (shopBtn) {
                shopBtn.onclick = () => game.openShop();
            }
            
            const inventoryBtn = document.getElementById('inventoryBtn');
            if (inventoryBtn) {
                inventoryBtn.onclick = () => game.openInventory();
            }
            
            const debugBtn = document.getElementById('debugBtn');
            if (debugBtn) {
                debugBtn.onclick = () => game.debugAddCompanion();
            }
            
            const encounterBtn = document.getElementById('encounterBtn');
            if (encounterBtn) {
                encounterBtn.onclick = () => game.openEncounterSelector();
            }
        }
        
        function setupModalListeners() {
            const closeShop = document.getElementById('closeShop');
            if (closeShop) {
                closeShop.addEventListener('click', () => game.closeShop());
            }
            
            const closeInventory = document.getElementById('closeInventory');
            if (closeInventory) {
                closeInventory.addEventListener('click', () => game.closeInventory());
            }
            
            const closeEncounter = document.getElementById('closeEncounter');
            if (closeEncounter) {
                closeEncounter.addEventListener('click', () => game.closeEncounterSelector());
            }
            
            const buyTab = document.getElementById('buyTab');
            const sellTab = document.getElementById('sellTab');
            
            if (buyTab) {
                buyTab.addEventListener('click', () => {
                    buyTab.classList.add('active');
                    sellTab.classList.remove('active');
                    game.renderShop('buy');
                });
            }
            
            if (sellTab) {
                sellTab.addEventListener('click', () => {
                    sellTab.classList.add('active');
                    buyTab.classList.remove('active');
                    game.renderShop('sell');
                });
            }
            
            // Close modals when clicking outside
            window.addEventListener('click', (e) => {
                const shopModal = document.getElementById('shopModal');
                const inventoryModal = document.getElementById('inventoryModal');
                const encounterModal = document.getElementById('encounterModal');
                
                if (e.target === shopModal) {
                    game.closeShop();
                }
                if (e.target === inventoryModal) {
                    game.closeInventory();
                }
                if (e.target === encounterModal) {
                    game.closeEncounterSelector();
                }
            });
        }
    </script>
</body>
</html>